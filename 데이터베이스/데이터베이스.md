### 데이터 베이스란
* 통합, 저장되어 운영되는 공용데이터
  * 실시간 접근, 변화, 동시 공용, 내용에 의한 참조가 가능해야함
* 파일 시스템 -> 발전 -> 데이터 베이스로 발전
* DBMS(Database Management System)이란
  * DB를 생성, 접근, 조작하기위한 소프트웨어
  * 필수 기능
    * 정의 : 데이터형과 구조(논리 <-> 물리) 데이터의 제약조건
    * 조작 : 데이터의 검색 갱신 삭제 삽입
    * 제어 : 무결성, 보안, 권한, 병행 제어 등
      * 무결성
        * 개체 무결성 - 기본키는 null이 올 수 없고 중복될 수 없음
        * 참조 무결성 - 외래키 값은 null이거나 참조 릴레이션의 기본키 값(혹은 후보키)이어야함
        * 도메인 무결성 - 필드의 값이 정의된 도메인에 속한 값이어야 함
        * 고유 무결성 - 고유 값을 가지도로 조건이 된경우 중복이 없어야 함
        * null 무결성 
        * 키 무결성 - 한 릴레이션에는 최소 하나의 키가 있어야 함 
 * 효과
   * 종속성 해결 : 응용 프로그램과 데이터 파일의 의존적인 부분 분리
   * 중복성 해결 : 일관성(중복 데이터 내용 불일치), 보안성(중복 데이터 보안 다름), 경제성(저장공간 낭비 최소화), 무결성(제어의 정확성) 보장
   * 독립성 해결 : 논리접 독립성(응용프로그램 <-> 데이버테이스) + 물리적 독립성(응용프로그램 <-> 저장장치)
 * 단점 : 복잡, 비용 증가, 전문가 부족, 백업과 회복 어려움 등
----

### 인덱스
* 정렬된 상태를 유지하는 색인
* 적절히 사용할 경우 검색 속도가 빨라짐
* 잘못사용할 경우 삭제, 수정 속도만 느려짐
* 주로 B+- Tree, Hash 인덱스(특수 경우에만) 알고리즘으로 이루어짐
----

### 키 Key
Key 란? 검색이나 정렬시 Tuple을 구분할 수 있는 기준이 되는 Attribute.
* 슈퍼키 supper key : 테이블 필드들의 부분집합으로 유일성을 만족해야함
* 후보키 candidate key : 기본 키가 될 수 있는 후보로 슈퍼키중에서 최소성을 만족해야함
* 기본키 primary key : 테이블이 특정 레코드 구별을 위해 선택한(후보키 중) 고유 식별자 
  - null 값을 가질 수 없음
  - 값의 변경이 적고, 단순한 것이 좋음
* 대체키 alternate key : 후보키중 기본키 제외 다른 키들, 보조키라고도 함
* 복합키 composite key : 키가 필드 여러개로 이루어진 경우
* 외래키 foreign key : 한 테이블의 키가 다른 테이블의 레코드를 유일하게 식별할 수 있는 키
  * 참조되는 테이블에서 유일한 값을 식별해야함
  * 참조하는 테이블에서는 중복된 값과 null값을 가질 수 있음
  * 참조 무결성 유지를 위해 참조되는 테이블이 변경 삭제 되는 경우 참조하는 테이블도 반영되야함
    * RESTRICTED : 참조되는 경우 삭제나 변경 불가
    * CASCADE : 참조되는 경우 참조하는 테이블도 같이 변경, 삭제
    * SET NULL : 참조되는 경우 참조하는 테이블에 NULL로 설정

> * 유일성 : Key로 하나의 Tuple을 유일하게 식별할 수 있음
> * 최소성 : 꼭 필요한 속성으로만 구성
----

### 정규화
* 불필요한 데이터를 없애고, 삽입/갱신/삭제 시 발생하는 이상현상을 방지
  * 이상현상 (Anomaly)
     * 삽입 이상 : 원하지 않는 자료(불필요한 자료)가 삽입되거나 자료가 부족해 삽입되지 않는 경우
     * 삭제 이상 : 하나의 자료만 삭제하고 싶지만, 튜플 전체가 삭제되는 경우
     * 갱신 이상 : 일부 튜플만 갱신되어 일관성이 없어지는 경우
* 함수적 종속성을 파악하고 한 릴레이션에 하나의 함수적 종속성만을 가지도록 정규화 단계를 거침
  * 함수적 종속성 : X -> Y : x의 값이 y의 값을 유일하게 결정함
  * 완전 함수적 종속성 : X의 칼럼이 여러개일떄 그 중 일부 칼럼으로만 식별할 수 없어야 함
* 제 1 졍규형 : 튜플의 모든 칼럼이 도메인에 속하는 하나의 값을 가져야함
* 제 2 정규형 : 모든 칼럼이 완전 함수적 종속을 만족
* 제 3 정규형 : 이행적 함수 종속이 없는 것. 즉 기본키를 제외한 속성들 간에 종속성이 없는 것
* BCNF 정규형 : 모든 X가 후보키여야함 
* 단점
  * 분해가 되는 만큼 추후 사용시 JOIN이 많이 필요함 등
  * 반정규화 진행 : 성능 향상을 위한 데이터 중복 허용, 등
  
 ----
 ### 조인 JOIN
 * INNER JOIN : SELECT a.name, b.age FROM ex_table a INNER JOIN join_table b ON a.no_emp = b.no_emp
 * LEFT OUTER JOIN : SELECT a.name, b.age FROM ex_table a LEFT OUTER JOIN join_table b ON a.no_emp = b.no_emp (A가 왼쪽)
 * RIGHT OUTER JOINI : SELECT a.name, b.age FROM ex_table a RIGHT OUTER JOIN join_table b ON a.no_emp = b.no_emp
 * FULL OUTER JOIN : SELECT a.name, b.age FROM ex_table a FULL OUTER JOIN join_table b ON a.no_emp = b.no_emp
 * CROSS JOIN : SELECT a.name, b.age FROM ex_table a CROSS JOIN join_table b
 * SELF JOIN : SELECT a.name, b.age FROM ex_table a, ex_table b
 
 ----
 ### 트랜잭션 Transaction
 * DB 상태를 변화시키기 위해 수행하는 작업 단위
 * 작업의 완전성을 보장해주는 것
  * 4가지 특징 ACID
    * 원자성(Atomicity) : 트랜잭션이 모두 반영되거나 모두 반영되지 않아야 함
    * 일관성(Consistency) : 트랜잭션 완료후에도 데이터의 일관성을 보장해야함
    * 고립성(Isolation) : 각각의 트랜잭션은 서로 간섭없이 독립적을 수행
    * 지속성(Durability) : 트랜잭션 완료후에는 영구적으로 결과가 반영됨
* 트랜잭션 상태 : Begin Tranjaction, Active(동작중), Partially Committed(커밋 요청이 들어옴, 성공시 Committed 실패시 Failed로 전이), Committed, Failed, Aborted
  * Commit : 트랜잭션이 성공적으로 끝났고 DB에 반영하기 위해 알려주는 연산
  * Rollback : 트랜잭션이 비정상적으로 종료되어 이정 상태로 되돌리는 연산
    * undo : 되돌려서 복구 == rollback
    * redo : 이전 작업을 다시 실행
* 여러 트랜잭션이 동시에 같은 데이터에 접근해서 일관성이 없어질 수 있음
  * dirty reads : 커밋 되지 않은 변경내용을 보는 것
  * non repetable reads : 두번 읽을때 다른 값을 읽는 것
  * phantom read : 없던 데이터가 갑자기 생김, 등 문제 발생
  > * Isolation level - 독립적인 수행을 하도록 작업중인 영역에 Locking하는 것
  >   * level 0 - Read Uncommitted : 처리중인 데이터 다른 트랜잭션이 읽는 것을 허용함
  >   * level 1 - Read Committed : 커밋된 데이터만 볼 수 있음 (dirty reads 해결)
  >   * level 2 - Repeatable read (dirty reads, non repetable reads 해결)
  >   * level 3 - Serializble (모두 해결)
  >  * 일관성이 보장되는 만큼 동시성은 떨어짐
  >  * 교착상태가 발생할 수 있음
----
### NOSQL
* SQL : Structured Query Language
* NoSQL : Not Only SQL
  * key-value, document, column-family, graph등의 모델로 구별됨
  * 주로 집합지향

* SQL 장점
  * 명확하게 정의된 스키마, 데이터 무결성 보장
  * 관계는 각 데이터를 중복없이 한번만 저장
* SQL 단점
  * 덜 유연함. 데이터 스키마를 사전에 계획하고 알려야 함. (나중에 수정하기 힘듬)
  * 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있음
  * 대체로 수직적 확장(단순히 서버 성능 향상)만 가능함

* NoSQL 장점
  * 스키마가 없어서 유연함. 언제든지 저장된 데이터를 조정하고 새로운 필드 추가 가능
  * 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨. 데이터 읽어오는 속도 빨라짐
  * 수직 및 수평 확장이 가능해서 애플리케이션이 발생시키는 모든 읽기/쓰기 요청 처리 가능
* NoSQL 단점
  * 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음
  * 데이터 중복을 계속 업데이트 해야 함
  * 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함 (SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능)

* SQL 데이터베이스 사용이 더 좋을 때
  * 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우
    * NoSQL에서는 여러 컬렉션을 모두 수정해야 하기 때문에 비효율적
  * 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우

* NoSQL 데이터베이스 사용이 더 좋을 때
  * 정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우
  * 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
  * 데이터베이스를 수평으로 확장해야 하는 경우 (막대한 양의 데이터를 다뤄야 하는 경우)
