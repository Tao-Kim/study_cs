### OSI 7계층 - [추천 사이트](https://shlee0882.tistory.com/110)
  * 통신이 일어나는 과정을 단계별로 나눈 것
    * 문제 발생시 그 단계만 수정하면 됨
  * 각 게층은 하위 계층의 기능만을 이용, 상위 계층에 기능을 제공
  * 물리 -> 데이터 링크 -> 네트워크 -> 전송 -> 세션 -> 표현 -> 응용
    1. 물리 계층 - 단지 데이터를 전기적인 신호로 변환해 주고 받는 기능을 진행 - 리피터, 케이블, 허브 등
    2. 데이터 링크 -> 안전한 정보 전달을 수행, 물리적인 네트워크 사이에 전송 담당 (정보의 흐름제어, 오류 검출, 등), MAC 주소를 가지고 통신함 - 브리지, 스위치
    3. 네트워크 ->  데이터를 모적지까지 안전하고 빠르게 전달하는 기능(라우팅), IP 주소를 이용 - 라우터, IP
    4. 전송 -> TCP/UDP 프로토콜을 이용해 통신을 활성화 - TCP, UDP
      > TCP : 신뢰적, 연결지향적 
      > UDP : 비신뢰적, 비연결성, 제어가 거의 없음, 헤더가 단순 -> 실시간 이용에 적합
    5. 세션 -> 데이터가 통신하기 위한 논리적인 연결(응용프로그램 관점) - API, Socket
    6. 표현 -> 데이터 표현에 독립성을 제공, 암호화, 인코딩 디코딩 - JPEG, MPEG, 등
    7. 응용 -> 최종 목적지로 응용 서비스를 수행 - HTTP, FTP SMTP, POP3 등
    
----
### TCP / UDP
* TCP
  * 패킷단위 - 세그먼트
  * 신뢰성 보장이 가장 중요 
    * 손실 : packet 손실 문제
    * 순서 바뀜 : packet 순서 바뀜
    * Congestion : 네트워크 혼잡한 문제
    * 등
  * 주로 IP와 함께 사용 TCP/IP
    * IP : 주소를 찾아줌 - 달든 장소로 정확하게 옮겨주는 역할
    * TCP : 흐름 관리, 데이터 정확성 확인
      * 흐름제어
        * host to host
        * 송신측, 수신측의 데이터 처리 속도를 조절해서 수신자의 버퍼 오버플로우를 방지
          * stop and wait : 매번 전송한 패킷 확인 응답 받는 방식
          * sliding window : 수신측에서 설정한 크기(윈도우 크기) 만큼 전송응답에따라 다음 패킷을 조절
      * 혼잡 제어
        * host to network
        * 네트워크 내의 패킷 수가 과하지 않게 방지
          * AIMD 점점 패킷 수를 늘려가며 전달
          * slow start AIMD와 유사하지만 좀더 빠르게 증가함
  * 전이중, 점대점 방식 : 전송이 양방향으로 일어날 수 있고, 각 연결이 정확히 2개의 종단점을 가짐 (수신대상이 정해지지 않은(멀티캐스팅) 불특정 다수(브로드캐스팅)를 대상으로 전송 불가)
  * UDP보다 느림 (연속성은 udp보다 떨어짐)
  * 연결형 서비스
    * 3-way handshaking으로 연결을 설정
      1. 클라이언트가 서버에 SYN(x) 패킷을 보냄
      2. 서버가 SYN(x)를 받고 클라이언트에게 받았다는 신호로 ACK(x+1)과 SYN(y)를 보냄
      3. 클라이언트가 서버의 응답을 받고 ACK(y+1)을 서버로 보냄
    * 4-way handshaking으로 연결을 해제
      1. 클라이언트가 서버에게 연결을 종료한다는 FIN 플래그 보냄
      2. 서버는 FIN 확인후 ACK를 클라이언트에게 보냄 (남은 데이터 전송은 이루어짐)
      3. 데이터를 모두 보내고 FIN 플래그를 클리언트에게 보냄
      4. 클라이언트는 FIN을 받고 ACK를 서버에 보냄 (수신중인 데이터가 남았다면 계쏙 받음)
        * 서버는 ACK 이후 소켓을 닫고, 클라이언트는 수신중인 데이터 모두 받고 닫음
* UDP
  * 패킷 단위 - 데이터그램
  * 비연결형 서비스 - 각각의 패킷은 다른 경로로 전송될 수 있음 - 데이터 순서가 보장되지 않음
  * 흐름제어가 없어 패킷 전송의 결과, 오류는 확인할 수 없음
  * UDP 헤더에 최소한의 오류만 검사함
  * 성능은 빠름 -> 실시간 서비스에 적합
----
### 대칭키 / 공개키
  * 대칭키
    * 암호화 복호화에 같은 암호키를 사용하는 방법 - 동일한 키를 주고받음 -> 속도는 빠르나 전달 과정에서 보안 위험
  * 공개키
    * 암호화(공개키), 복호화(비밀키)로 이루어짐 - 암호화 복호화가 복잡함
  * 대칭키 전달 과정을 공개키로 하는 방식으로 발전해서 SSL의 시초가 됨
----
### HTTP hypertext transfer protocol
* 인터넷에서 클라이언트와 서버가 자원을 주고 받을때 쓰는 통신 규약
* http는 텍스트 교환이므로 노출 문제가 있음 -> https로 발전
  * https : SSL 프로토콜을 사용해 클라이언트와 서버가 자원을 주고받음 - 텍스트를 암호화함
    * 공개키방식으로 - CA(인증서 발급 조직)을 이용함
    
 http 내용 추가 필요
 [참고사이트](https://github.com/Donsworkout/techInterview/blob/master/network/network.md)
----
### REST
* URI(Uniform Resource Identifier) 를 통해 자원(Resource) 을 명시하고, HTTP Method (POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 행위(CRUD operation) 을 명시하고 표현(html, json ...) 하는 것
----
### HTTP VS SOCKET
[참고사이트](https://mangkyu.tistory.com/48)
* http 1.1부터 keep-alive 지원함
* 통신 방식 차이로 기존 소켓은 http 프로토콜로 구현하기도 함
* polling, long polling, streaming
* 현재는 websocket으로 발전중 - [참고사이트](https://d2.naver.com/helloworld/1336)
----
### 쿠키, 세션
* 쿠키
  * 저장위치 : 클라이언트
  * 보안 취약
  * 만료시간이 지정되며 브라우저 종료시에도 유지됨
* 세션
  * 저장위치 : 서버
  * 보안 비교적 강함
  * 브라우저 종료시 지워짐
  * 서버 처리가 느려짐
* 토큰 방식으로 발전중
