### [Design Pattern] 개요

---

> 일종의 설계 기법이며, 설계 방법이다.



* #### 목적

  SW **재사용성, 호환성, 유지 보수성**을 보장.

  <br>

* #### 특징

  **디자인 패턴은 아이디어**임, 특정한 구현이 아님.

  프로젝트에 항상 적용해야 하는 것은 아니지만, 추후 재사용, 호환, 유지 보수시 발생하는 **문제 해결을 예방하기 위해 패턴을 만들어 둔 것**임.

  <br>

* #### 장점과 단점
   * 장점
      * 개발자 간의 원할한 의사소통
      * 소프트웨어 구조 파악 용이
      * 재사용을 통한 개발 시간 단축
      * 설계 변경 요쳥에 대한 유연한 대처
   * 단점
      * 객체지향 설계/구현 위주로 사용된다.
      * 초기 투자 비용 부담

* #### 원칙

  ##### SOLID (객체지향 설계 원칙)

  (간략한 설명)

  1. ##### Single Responsibility Principle

     > 하나의 클래스는 하나의 역할만 해야 함.

  2. ##### Open - Close Principle

     > 확장 (상속)에는 열려있고, 수정에는 닫혀 있어야 함.

  3. ##### Liskov Substitution Principle

     > 자식이 부모의 자리에 항상 교체될 수 있어야 함.

  4. ##### Interface Segregation Principle

     > 인터페이스가 잘 분리되어서, 클래스가 꼭 필요한 인터페이스만 구현하도록 해야함.

  5. ##### Dependency Inversion Property

     > 상위 모듈이 하위 모듈에 의존하면 안됨.
     >
     > 둘 다 추상화에 의존하며, 추상화는 세부 사항에 의존하면 안됨.

<br>

* #### 분류 (중요)

`3가지 패턴의 목적을 이해하기!`

1. 생성 패턴 (Creational) : 객체의 **생성 방식** 결정

   Class-creational patterns, Object-creational patterns.

   ```text
   예) DBConnection을 관리하는 Instance를 하나만 만들 수 있도록 제한하여, 불필요한 연결을 막음.
   ```
   - Abstract Factory (추상 팩토리)  
      - 동일한 주제의 다른 팩토리를 묶어 준다.
   - Builder
      - 생성(construction)과 표기(representation)를 분리해 복잡한 객체를 생성한다
   - Factory Method
      - 생성할 객체의 클래스를 국한하지 않고 객체를 생성한다.
   - Prototype (원형)
      - 기존 객체를 복제함으로써 객체를 생성한다.
   - Singleton (단일체)
      - 한 클래스에 한 객체만 존재하도록 제한한다.
   <br>

2. 구조 패턴 (Structural) : 객체간의 **관계**를 조직

   ```text
   예) 2개의 인터페이스가 서로 호환이 되지 않을 때, 둘을 연결해주기 위해서 새로운 클래스를 만들어서 연결시킬 수 있도록 함.
   ```
      - Adapter (적응자)
         - 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록, 타 클래스의 인터페이스를 기존 인터페이스에 덧씌운다.
      - Bridge (가교)
         - 추상화와 구현을 분리해 둘을 각각 따로 발전시킬 수 있다.
      - Composite (복합체)
         - 0개, 1개 혹은 그 이상의 객체를 묶어 하나의 객체로 이용할 수 있다.
      - Decorator (장식자)
         - 기존 객체의 매서드에 새로운 행동을 추가하거나 오버라이드 할 수 있다.
      - Façade (퍼사드)
         - 많은 분량의 코드에 접근할 수 있는 단순한 인터페이스를 제공한다.
      - Flyweight (플라이급)
         - 다수의 유사한 객체를 생성·조작하는 비용을 절감할 수 있다.
      - Proxy (프록시)
         - 접근 조절, 비용 절감, 복잡도 감소를 위해 접근이 힘든 객체에 대한 대역을 제공한다.
   
<br>

3. 행위 패턴 (Behavioral): 객체의 **행위**를 조직, 관리, 연합

   ```text
   예) 하위 클래스에서 구현해야 하는 함수 및 알고리즘들을 미리 선언하여, 상속시 이를 필수로 구현하도록 함.
   ```
      - Chain of Responsibility (책임연쇄)
         - 책임들이 연결되어 있어 내가 책임을 못 질 것 같으면 다음 책임자에게 자동으로 넘어가는 구조
      - Command (명령)
         - 위의 명령어를 각각 구현하는 것보다는 위 그림처럼 하나의 추상 클래스에 메서드를 하나 만들고 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행하는 것
      - Interpreter (해석자)
         - 문법 규칙을 클래스화한 구조를 갖는SQL 언어나 통신 프로토콜 같은 것을 개발할 때 사용
      - Iterator (반복자)
         - 반복이 필요한 자료구조를 모두 동일한 인터페이스를 통해 접근할 수 있도록 메서드를 이용해 자료구조를 활용할 수 있도록 해준다.
      - Mediator (중재자)
         - 클래스간의 복잡한 상호작용을 캡슐화하여 한 클래스에 위임해서 처리 하는 디자인 패턴
      - Memento (메멘토)
         - Ctrl + z 와 같은 undo 기능 개발할 때 유용한 디자인패턴. 클래스 설계 관점에서 객체의 정보를 저장
      - Observer (감시자)
         - 어떤 클래스에 변화가 일어났을 때, 이를 감지하여 다른 클래스에 통보해주는 것
      - State (상태)
         - 동일한 동작을 객체의 상태에 따라 다르게 처리해야 할 때 사용하는 디자인 패턴
      - Strategy (전략)
         - 알고리즘 군을 정의하고 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 해준다.
      - Template Method
         - 상위 클래스에서는 추상적으로 표현하고 그 구체적인 내용은 하위 클래스에서 결정되는 디자인 패턴
      - Visitor (방문자)
         - 각 클래스의 데이터 구조로부터 처리 기능을 분리하여 별도의 visitor 클래스로 만들어놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 하는 것
<br>


### 참고 사이트
* [**(tistory) Gone - GoF의 디자인패턴 간단 정리.**](https://gone-sw.tistory.com/4)