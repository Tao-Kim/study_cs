### 메모리 관리 배경
* 메모리 관리장치(MMU)가 논리 주소를 물리 주소로 변환
* 메모리가 한정적이기에 가상 메모리가 존재
* 메모리 공간 구별을 위해 base, limit 등으로 관리됨 - 다른 프로세스의 메모리 공간에 접근 제한됨
* swapping - cpu 할당 시간이 끝난 메모리를 보조기억장치에 보내고 다른 프로세스의 메모리를 불러오는 기법(혹은 메모리 공간이 부족해서 하기도 함)
* 단편화(fragmentation) : 메모리 적재, 제거가 반복되며 생기는 공간 사이 틈으로 외부 단편화, 내부 단편화가 존재

### 메모리 관리 기법
* 연속 메모리 관리
  * 프로그램 전체가 연속된 공간에 할당됨
  * 고정 분할 기법(내부 단편화), 동적 분할 기법(외부 단편화)
  
* 불연속 메모리 관리
  * 프로그램 일부가 다른 주소 공간에 할당됨
  * 페이징  
    * 고정 사이즈의 조각(논리 메모리 - 페이지, 물리 메모리 - 프레임)으로 분리되어 적절히 배치하는 방법
    * 내부 단편화 문제
  * 세그멘테이션
    * 서로 다른 크기(시작 물리 주소 + 길이)의 논리적 단위인 세그먼트로 분할
    * 외부 단편화 문제
    
### 가상 메모리
* 프로스세 전체가 메모리에 올라오지 않아도 되게끔 하는 기법 - 실제 필요한 부분만 올라옴

### 페이지 교체
* FIFO(first in first out) 
  * 가장 먼저 들어온 페이지를 교체하는 것 
  * 쉽고 간단하나 오래된 페이지가 불필요하다는 보장은 없음
  * belady의 모순 존재 - 페이지 프레임을 늘렸는데 페이지 부재가 더 발생하는 경우
* OPT(Optimal Page Replacement)
  * 앞으로 가장 사용하지 않을 페이지를 교체
  * 가장 부재율이 낮으나 구현이 어려움
* LRU(Least Recently Used) 사용한지 오래된 페이지 교체
* LFU(Least Frequently Used) 참조 횟수가 가장 적은 페이지 교체 (카운트 해야함)
