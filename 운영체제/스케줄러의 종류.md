### 스케줄러(Scheduler)

- 스케줄링 알고리즘을 알기 전에 스케줄러에 대해 알아보자
- 프로세스들은 자신이 종료될 때까지 수많은 큐들을 돌아다닌다. OS는 이 큐 안에 있는 프로세스 중 하나를 선택해야 하며, 이러한 일을 `스케줄러(Scheduler)`가 담당한다.
- 작업 큐(Job Queue) : 현재 시스템 내의 모든 프로세스의 집합
- 준비 큐(Ready Queue) : 현재 메모리 내에 있으면서 CPU를 할당받고 실행되기 위해 기다리는 프로세스의 집합
- 장치 큐(Device Queue) : 각각의 장치마다 서비스를 기다리며 줄 서 있는 프로세스의 집합





**[장기 스케줄러(Long-term Scheduler)]**

<!-- 메모리는 한정되어 있는데 많은 프로세스들이 한꺼번에 메모리에 올라올 경우, 대용량 메모리(일반적으로 디스크)에 임시로 저장된다. 이 Pool에 저장되어 있는 프로세스 중 어떤 프로세스에 메모리를 할당하여 Ready Queue로 보낼지 결정하는 역할을 한다.
- 메모리와 디스크 사이의 스케줄링을 담당한다.
- 프로세스에 Memory(및 각종 리소스)를 할당한다.(admit)
- degree of Multiprogramming 제어(메모리에 여러 프로그램이 올라가는 것. 즉, 몇 개의 프로그램이 올라갈 것인지를 제어)
- 즉, 디스크와 같은 저장 장치에 작업들을 저장해 놓고 필요할 때 Jab Queue에서 꺼내 Ready Queue에 적재(메모리로 적재)한다.
- 프로세스의 상태 : 시작 상태(New) -> 준비 상태(Ready) -->

- 메모리는 한정되어 있는데 많은 프로세스들이 메모리에 한꺼번에 올라올 경우, 대용량 메모리(디스크)에 임시로 저장한다. 이 Pool(디스크) 내의 저장되어 있는 프로세스 중 어떤 순서로 프로세스를 메모리에 적재할지 결정한다.

- **메모리와 디스크 사이의 스케줄링**을 담당한다. 따라서 상대적으로 호출되는 빈도가 적다.
- 즉, 디스크와 같은 저장 장치에 작업들을 저장해 놓고 필요할 때 실행할 작업을 Job Queue에서 꺼내 Ready Queue를 통해서 메인 메모리에 적재한다.
- degree of Multiprogramming 제어(메모리에 여러 프로그램이 올라가는 것. 즉, 몇 개의 프로그램이 올라갈 것인지를 제어)
- 프로세스의 상태
  - 시작 상태(New) -> 준비 상태(Ready)
  - Running(or Ready) -> Terminated




**[단기 스케줄러(Short-term Scheduler)]**

<!--
- CPU와 메모리 사이의 스케줄링을 담당한다.
- Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정한다.
- 프로세스에 CPU를 할당한다.
- 프로세스의 상태 : ready -> running -> waiting -> ready -->

- **CPU와 메모리 사이의 스케줄링**을 담당한다. 따라서 장기 스케줄러에 비해 매우 많이 호출된다.
- 우선, CPU에게 필요한 데이터를 확보해주고 메모리에 있는 프로세스 중 하나를 선택해서 CPU를 할당한다.
- 즉, Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정한다.
- Ready Queue에 있는 프로세스 중 **먼저 도착한 프로세스에게 CPU를 할당**한다.(=디스페처)
- 프로세스의 상태 : ready -> running -> waiting -> ready



**[중기 스케줄러(Medium-term Scheduler)]**

<!--
- 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아낸다.(Swapping)
- 프로세스에게서 Memory를 deallocate
- degree of Multiprogramming 제어
- 현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케줄러
- 프로세스의 상태 : ready -> suspended
-->

- 시분할 시스템에서 추가로 사용하며, 메모리에 대한 가중을 완화시켜주기 위해 중기 스케줄러 도입.
- CPU를 차지하기 위한 경쟁이 심해질 때, 우선순위가 낮은 프로세스들을 잠시 제거한 뒤, 나중에 경쟁이 완화되었을 때 다시 디스크에서 메모리로 불러와 중단되었던 지점부터 실행시킨다. (Swapping)
- 즉, 프로세스들이 서로 CPU를 차지하려고 경쟁이 심해지면 Swapping 기법을 활용하여 메모리를 관리함으로써 너무 많은 프로그램이 동시에 올라가는 것을 조절한다.
- 프로세스의 상태 : ready -> suspended



swap out : 메모리에서 디스크로 잠시 나가는 상태
swap in : 디스크에서 메모리로 다시 들어오는 상태



**[Process state - suspended]**

Suspended(stopped) : 외부적인 이유로 프로세스의 수행이 정지된 상태로 메모리에서 내려간 상태를 의미한다. 프로세스 전부 디스크로 Swap out 된다. 

Blocked 상태는 다른 I/O 작업을 기다리는 상태이기 때문에 스스로 ready state 로 돌아갈 수 있지만, 이 상태는 외부적인 이유로 suspending 되었기 때문에 스스로 돌아갈 수 없다. 



### About 중기 스케줄러

중기 스케줄러에 대해 더 알아보자.

시분할 시스템 운영체제에서는 `중기 스케줄러`를 추가로 도입한다.

Unix나 Window에서는 장기 스케줄러가 거의 사용되지 않는다고 한다. 왜냐하면 일단 작업이 큐에 들어오면 닥치는대로 메모리에 올린다. 물론 OS 자체적인 제한을 두거나 사용자 스스로 제한을 할 수 있도록 하기도 한다.



이를 시분할 시스템에서 어느정도 시스템적으로 완하하기 위해 중기 스케줄러를 도입한 것 같다. 중기 스케줄러를 사용해 **메모리에서 CPU를 쓰기 위해 경쟁하고 있는 프로세스들을 몇 개 제거**한다. 그리고 추후에 **다시 메모리로 불러와서 중단되었던 지점부터 다시 실행을 재게**하게 하는 것이다. -> 스와핑(Swapping) 기법


<img width="682" alt="scheduler2" src="https://user-images.githubusercontent.com/33534771/87003398-82df2880-c1f6-11ea-99da-9deafad24475.png">

<img width="402" alt="scheduler" src="https://user-images.githubusercontent.com/33534771/87003325-604d0f80-c1f6-11ea-9849-589fc4976821.png">


정리하면 중기 스케줄러에 의해 프로세스들이 CPU를 차지하려고 경쟁이 심해지면, `Swap out` 되어 메모리를 떠났다가 다시 `Swap in` 되어 메모리로 돌아온다는 것이다.

<img width="682" alt="scheduler2" src="https://user-images.githubusercontent.com/33534771/87003398-82df2880-c1f6-11ea-99da-9deafad24475.png">


- 작업(Job)이 도착하면 입력 큐(또는 준비 큐)에서 장기 스케줄러에 의해 메모리에 적재된다.
- 단기 스케줄러에 의해 선택되어 CPU를 할당받게 된다.
- Memory Scheduler는 중기 스케줄러의 역할을 하며, 프로세스들이 메모리에서 디스크로 Swap in, Swap out 되는 것을 볼 수 있다.



#### [정리] 장기 스케줄러 vs 단기 스케줄러


`장기 스케줄러와 단기 스케줄러의 가장 큰 차이점은 실행 빈도이다.`

프로세스는 빠르게 실행되고 이러한 프로세스들을 처리하기 위해 즉, 프로세스들 간의 우선순위를 정하기 위해 단기 스케줄러가 동작한다. 여기서 스케줄링의 시간이 지연되면 안되기 때문에 단기 스케줄러는 상당히 빨라야 하고 호출 빈도수가 많다.



그에 반해 시스템에 새로운 작업이 생성되어 들어오는 것은 분 단위로 프로세스의 함수가 실행되는 시간에 비해 무지 길다. 추가로 시스템에서 이탈하는 프로세스도 관리하지만, 장기 스케줄러는 단기 스케줄러보다 호출 빈도수가 매우 적다. 그리고 장기 스케줄링은 스케줄링 시간이 꽤 걸리더라도 신중하게 프로세스를 선택한다. 

만약, 장기 스케줄링이 I/O 프로세스나 CPU 중심 프로세스 중 한쪽으로 편중해서 프로세스를 받아온다면 ready Queue, device Queue 한쪽에 프로세스가 집중되어 버리게 되어 단기 스케줄러의 균형도 붕괴된다.


++ 전체적인 흐름 추가하기(규글)

### Reference

- [OS - 스케줄러의 종류](http://blog.naver.com/PostView.nhn?blogId=4717010&logNo=60208674547)
- [[OS] 스케줄러란?](https://k39335.tistory.com/32)
- [[운영체제] 스케줄러](https://kim6394.tistory.com/177)

