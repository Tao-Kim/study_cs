## 알고리즘(코딩테스트) 문제 접근법

<br>

#### Data Structure

1. **배열** : 임의의 사이즈를 선언 (Heap, Queue, Binary Tree, Hashing 사용)
2. **스택** : 행 특정조건에 따라 push, pop 적용
3. **큐** : BFS를 통해 순서대로 접근할 때 적용
4. **연결리스트** : 배열 구현, 포인터 구현 2가지 방법 - 삽입,삭제가 많이 일어날 때 활용하기
5. **그래프** : 경우의 수, 연결 관계가 있을 때 적용
6. **해싱** : 데이터 수만큼 메모리에 생성할 수 없는 상황에 적용
7. **트리** : Heap과 BST(이진탐색)

<br>

#### Algorithm

1. **★재귀(Recursion)** : 가장 많이 활용. 중요한 건 호출 횟수를 줄여야 함 (반복 조건, 종료 조건 체크)
2. **★BFS, DFS** : 2차원 배열에서 확장 시, 경우의 수를 탐색할 때 구조체(class)와 visited 체크를 사용함
3. **★정렬** : 퀵소트나 머지소트가 대표적이지만, 보통 퀵소트를 사용함
4. **★메모이제이션(memoization)** : 이전 결과가 또 사용될 때, 반복 작업을 안하도록 저장
5. **★이분탐색(Binary Search)** : logN으로 시간복잡도를 줄일 수 있는 간단하면서 핵심적인 알고리즘
6. **최소신장트리(MST)** : 사이클이 포함되지 않고 모든 정점이 연결된 트리에 사용 (크루스칼, 프림)
7. **최소공통조상(LCA)** : 경우의 수에서 조건이 겹치는 경우. 최단 경로 탐색시 공통인 경우가 많을 때 적용
8. **Disjoint-Set** : 서로소 집합. 인접한 집함의 모임으로 Tree의 일종이며 시간복잡도가 낮음
9. **분할 정복** : 머지 소트에 사용되며 범위를 나누어 확인할 때 사용
10. **트라이(Trie)** : 모든 String을 저장해나가며 비교하는 방법
11. **비트마스킹** : `|는 OR, &는 AND, ^는 XOR` <<를 통해 메모리를 절약할 수 있음

<br>

- Sort 시간복잡도

<img src="https://gmlwjd9405.github.io/images/algorithm-quick-sort/sort-time-complexity.png">

