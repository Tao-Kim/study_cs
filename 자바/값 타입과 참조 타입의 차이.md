### 값 타입 vs 참조 타입

가장 큰 차이점은 데이터가 저장되는 메모리 상의 위치이다.

편의상 값 타입은 원시 타입(Primitive Type)이라고 부르겠다. 참조 타입(Reference Type)

- 원시 타입 : 크기가 작고 고정적이기 때문에 스택 영역에 저장된다.
- 참조 타입 : 크기가 크고 가변적이기 때문에 동적으로 관리되는 힙에 저장된다.

이처럼 저장되는 위치의 차이는 여러 차이점을 만든다. 



1) 메모리 및 접근 속도

- 원시 타입
  - 선언시 스택에 즉시 생성되므로 선언 직후부터 데이터를 저장하는 용도로 사용할 수 있다.
- 참조 타입 
  - 선언에 의해 참조만 생성될 뿐, 데이터를 저장할 수 있는 실제 메모리가 할당된 것은 아니다. 따라서 선언 즉시 사용할 수 없다. **반드시 new 연산자로 메모리를 할당받아 초기화해야 한다.** 
  - '스택' 메모리에는 참조값만 존재하고 실제 값은 '힙' 메모리에 존재한다. **값을 필요로 할 때마다 언박싱 과정을 거쳐여 하므로 원시타입과 비교해서 접근 속도가 느려진다.**

> 예외적으로 엄청 큰 숫자를 복사해야 한다면, 참조값만 넘길 수 있는 참조 타입이 좋을 수도 있다.



![img](https://k.kakaocdn.net/dn/uj0bm/btqvqfnwD5S/tKWdT5AKJDttoyuF5baZZK/img.gif)

<center>차지하는 메모리의 양</center>

Boolean의 경우에는 128배나 많은 메모리를 사용하게 된다. 

2) 소멸 시점

- 원시 타입 : 변수를 선언한 메소드가 종료될 때 혹은 소속된 객체가 사라질 때, 소멸된다.
- 참조 타입 : 더 이상 참조하는 변수가 없을 때 GC에 의해 제거된다.



3) 복사

- 원시 타입 : 복사에 의해 별개의 복사본이 생성되며 복사 후 원본과 복사본은 별개의 변수이다. 완전히 다른 두 개의 변수가 생성되는 것이다.
- 참조 타입 : 참조 타입끼리의 대입은 힙 영역에 존재하는 데이터를 참조하는 참조자가 하나 더 늘어날 뿐이다. 따라서 별도의 메모리가 추가로 할당되지 않는다. 그래서 둘 중 하나를 변경하면 다른 참조자는 같은 값을 참조하기 때문에 같이 변경된다. (해결하기 위해서는 Deep Copy 해야 한다.)



4) Null 

- 원시 타입 : Null 값을 저장할 수 없다.
- 참조 타입 : Null 값을 저장할 수 있다.



**결론**

성능과 메모리에 장점이 있는 원시 타입을 먼저 고려해본다. 만약, Null을 다뤄야 하거나 제네릭 타입에서 사용되어야 한다면 참조 타입을 사용한다.



### 참고

- [값타입, 참조타입 차이]([https://rsd885.tistory.com/entry/%EA%B0%92%ED%83%80%EC%9E%85-%EC%B0%B8%EC%A1%B0%ED%83%80%EC%9E%85-%EC%B0%A8%EC%9D%B4](https://rsd885.tistory.com/entry/값타입-참조타입-차이))
- [Java에서 원시타입 vs 참조타입 어떤 걸 사용해야 할까?](https://siyoon210.tistory.com/139)

